/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Notification
 #	author : miyako
 #	2016/08/01
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

namespace Observer
{
	//context management
	std::vector<CUTF16String> notificationNames;
	std::vector<CUTF16String> notificationUserInfoKeys;
	std::vector<CUTF16String> notificationUserInfoValues;
	
	//constants
	process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0N\0O\0T\0I\0F\0I\0C\0A\0T\0I\0O\0N\0\0\0";
	process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
	process_stack_size_t CALLBACK_PROCESS_STACK_SIZE = 0;
	
	//callback management
	C_TEXT callbackMethodName;
	method_id_t callbackMethodId = 0;
	process_number_t monitorProcessId = 0;
	bool shouldCallMethod = false;
	bool shouldDie = false;
}

void listenerLoop()
{
	Observer::shouldDie = false;
	
	while(!Observer::shouldDie)
	{
		PA_YieldAbsolute();
		while(Observer::notificationNames.size())
		{
			PA_YieldAbsolute();
			
			C_TEXT processName;
			generateUuid(processName);
			PA_NewProcess((void *)listenerLoopExecute,
										Observer::CALLBACK_PROCESS_STACK_SIZE,
										(PA_Unichar *)processName.getUTF16StringPtr());
			
			if(Observer::shouldDie)
				break;
		}
		
		if(!Observer::shouldDie)
		{
			PA_FreezeProcess(PA_GetCurrentProcessNumber());
		}
	}
	
	Observer::monitorProcessId = 0;
	
	PA_KillProcess();
}

void listenerLoopStart()
{
	if(!Observer::monitorProcessId)
	{
		Observer::monitorProcessId = PA_NewProcess((void *)listenerLoop, Observer::MONITOR_PROCESS_STACK_SIZE, Observer::MONITOR_PROCESS_NAME);
	}
}

void listenerLoopFinish()
{
	if(Observer::monitorProcessId)
	{
		//set flag
		Observer::shouldDie = true;
		
		//tell listener to die
//		while(Observer::monitorProcessId)
//		{
//			PA_YieldAbsolute();
			PA_UnfreezeProcess(Observer::monitorProcessId);
//		}
		
	}
}

void listenerLoopExecute()
{
	std::vector<CUTF16String>::iterator n = Observer::notificationNames.begin();
	std::vector<CUTF16String>::iterator k = Observer::notificationUserInfoKeys.begin();
	std::vector<CUTF16String>::iterator v = Observer::notificationUserInfoValues.begin();
	
	CUTF16String notificationName = *n;
	CUTF16String notificationUserInfoKey = *k;
	CUTF16String notificationUserInfoValue = *v;
	
	if(Observer::callbackMethodId)
	{
		PA_Variable	params[3];
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Unistring);
		params[2] = PA_CreateVariable(eVK_Unistring);
		
		PA_Unistring nn = PA_CreateUnistring((PA_Unichar *)notificationName.c_str());
		PA_SetStringVariable(&params[0], &nn);
		PA_Unistring kk = PA_CreateUnistring((PA_Unichar *)notificationUserInfoKey.c_str());
		PA_SetStringVariable(&params[1], &kk);
		PA_Unistring vv = PA_CreateUnistring((PA_Unichar *)notificationUserInfoValue.c_str());
		PA_SetStringVariable(&params[2], &vv);
		
		//the method could be paused or traced
		Observer::notificationNames.erase(n);
		Observer::notificationUserInfoKeys.erase(k);
		Observer::notificationUserInfoValues.erase(v);
		
		PA_ExecuteMethodByID(Observer::callbackMethodId, params, 3);
		
		PA_ClearVariable(&params[0]);
		PA_ClearVariable(&params[1]);
		PA_ClearVariable(&params[2]);
	}else{
		//the method could have been removed
		Observer::notificationNames.erase(n);
		Observer::notificationUserInfoKeys.erase(k);
		Observer::notificationUserInfoValues.erase(v);
	}
}

#pragma mark -

void StartNotification()
{
	if(!Observer::shouldDie)
	{
		PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopStart, NULL);
	}
}

void StopNotification()
{
	if(!Observer::shouldDie)
	{
		PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL);
	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	StartNotification();
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
		CFNotificationCenterRemoveEveryObserver(distributedCenter, NULL);
		
		StopNotification();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
// --- Notification

		case 1 :
			Notification_SET_METHOD(pResult, pParams);
			break;

		case 2 :
			Notification_Get_method(pResult, pParams);
			break;

		case 3 :
			Notification_ADD_OBSERVER(pResult, pParams);
			break;

		case 4 :
			Notification_REMOVE_OBSERVER(pResult, pParams);
			break;

		case 5 :
			Notification_POST(pResult, pParams);
			break;

	}
}

// --------------------------------- Notification ---------------------------------


void Notification_SET_METHOD(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	if(!Param1.getUTF16Length())
	{
		
		Observer::shouldCallMethod = false;
		
	}else{
		
		method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param1.getUTF16StringPtr());
		
		if(methodId)
		{
			if(methodId != Observer::callbackMethodId)
			{
				Observer::callbackMethodName.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
				Observer::callbackMethodId = methodId;
			}
			Observer::shouldCallMethod = true;
		}
	}
}

void Notification_Get_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	Observer::callbackMethodName.setReturn(pResult);
}

static void Callback(CFNotificationCenterRef center,
										 void *observer,
										 CFStringRef name,
										 const void *object,
										 CFDictionaryRef userInfo)
{
	if(Observer::shouldCallMethod)
	{
		StartNotification();
	
		CUTF16String n, k, v;
		uint32_t len = CFStringGetLength(name);
		uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		if(CFStringGetCString(name, (char *)&buf[0], size, kCFStringEncodingUnicode))
		{
			n = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
		Observer::notificationNames.push_back(n);
		
		NSDictionary *_userInfo = (NSDictionary *)userInfo;
		NSArray *allKeys = [_userInfo allKeys];

		NSMutableArray *allValues = [[NSMutableArray alloc]init];
		
		for(NSUInteger i = 0; i < [allKeys count]; ++i)
		{
			[allValues addObject:[_userInfo objectForKey:[allKeys objectAtIndex:i]]];
		}
		
		NSString *keys = [allKeys componentsJoinedByString:@"\n"];
		NSString *values = [allValues componentsJoinedByString:@"\n"];
		
		[allValues release];
		
		len = [keys length];
		size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		buf.resize(size);
		if([keys getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
		{
			k = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
		Observer::notificationUserInfoKeys.push_back(k);
		
		len = [values length];
		size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		buf.resize(size);
		if([values getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
		{
			v = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
		
		Observer::notificationUserInfoValues.push_back(v);
		PA_UnfreezeProcess(Observer::monitorProcessId);
	}
}

void Notification_ADD_OBSERVER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	Param1.fromParamAtIndex(pParams, 1);
	NSString *notificationId = Param1.copyUTF16String();
	
	CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
	CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;
	CFNotificationCenterAddObserver(distributedCenter,
																	NULL,
																	Callback,
																	(CFStringRef)notificationId,
																	NULL,
																	behavior);
	
	[notificationId release];
}

void Notification_REMOVE_OBSERVER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	Param1.fromParamAtIndex(pParams, 1);
	NSString *notificationId = Param1.copyUTF16String();
	
	CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
	CFNotificationCenterRemoveObserver(distributedCenter, NULL, (CFStringRef)notificationId, NULL);

	[notificationId release];
}

void Notification_POST(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	StartNotification();
	
	NSMutableDictionary *userInfo = [[NSMutableDictionary alloc]init];
	unsigned int s1 = Param2.getSize();
	unsigned int s2 = Param3.getSize();
	unsigned int size = s1 > s2 ? s2 : s1;
	
	for(unsigned int i = 1; i < size; ++i)
	{
		NSString *key = Param2.copyUTF16StringAtIndex(i);
		NSString *value = Param3.copyUTF16StringAtIndex(i);
		if([key length])
			[userInfo setObject:value forKey:key];
		[key release];
		[value release];
	}
	
	NSString *notificationId = Param1.copyUTF16String();
	CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
	CFNotificationCenterPostNotification(distributedCenter,
																			 (CFStringRef)notificationId,
																			 NULL,
																			 (CFDictionaryRef)userInfo,
																			 true);

	[userInfo release];
	[notificationId release];
}

